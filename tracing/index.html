<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Letter Tracing Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', 'Arial Rounded MT Bold', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            padding-top: 70px;
            overflow-x: hidden;
        }

        /* Navigation Bar */
        .game-nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 0.5rem 1rem;
            z-index: 10000;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .game-nav a {
            text-decoration: none;
            color: #667eea;
            font-weight: 600;
            font-size: 1.2rem;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .game-nav a:hover {
            background: rgba(102, 126, 234, 0.1);
        }

        .game-nav .logo {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .container {
            background: white;
            border-radius: 30px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            width: 100%;
            text-align: center;
        }

        h1 {
            color: #ff6b9d;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .progress-container {
            margin: 20px 0;
            background: #f0f0f0;
            border-radius: 20px;
            padding: 10px;
            position: relative;
            width: 100%;
            height: 50px;
        }

        .progress-bar {
            background: linear-gradient(90deg, #4ecdc4, #44a08d);
            height: 30px;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 1.5em;
            width: 100%;
            min-width: 120px;
        }

        .canvas-container {
            position: relative;
            margin: 30px auto;
            background: #f9f9f9;
            border-radius: 20px;
            padding: 20px;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        #tracingCanvas {
            display: block;
            margin: 0 auto;
            cursor: crosshair;
            touch-action: none;
            border-radius: 10px;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        button {
            background: linear-gradient(135deg, #ff6b9d, #ff8fab);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2em;
            border-radius: 25px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(255, 107, 157, 0.4);
            transition: all 0.3s ease;
            min-width: 150px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 157, 0.6);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            box-shadow: none;
        }

        .toggle-btn {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.4);
        }

        .toggle-btn:hover {
            box-shadow: 0 6px 20px rgba(78, 205, 196, 0.6);
        }

        .reset-btn {
            background: linear-gradient(135deg, #feca57, #ff9ff3);
            box-shadow: 0 4px 15px rgba(254, 202, 87, 0.4);
        }

        .reset-btn:hover {
            box-shadow: 0 6px 20px rgba(254, 202, 87, 0.6);
        }

        .success-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3em;
            color: #4ecdc4;
            font-weight: bold;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 10;
        }

        .success-message.show {
            opacity: 1;
            animation: bounce 0.6s ease;
        }

        @keyframes bounce {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
        }

        /* Star animation for success */
        .star {
            position: absolute;
            color: #ffd700;
            font-size: 2em;
            pointer-events: none;
            animation: sparkle 1s ease-out forwards;
        }

        @keyframes sparkle {
            0% {
                opacity: 1;
                transform: scale(0) rotate(0deg);
            }
            100% {
                opacity: 0;
                transform: scale(1.5) rotate(360deg);
            }
        }

        /* Menu styles */
        .menu-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .menu-options {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 20px 0;
        }

        .menu-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 25px;
            font-size: 1.1em;
            border-radius: 20px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            transition: all 0.3s ease;
        }

        .menu-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .menu-btn.active {
            background: linear-gradient(135deg, #ff6b9d, #ff8fab);
            box-shadow: 0 4px 15px rgba(255, 107, 157, 0.4);
        }

        .character-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
            gap: 10px;
            max-width: 500px;
            width: 100%;
            margin: 20px 0;
        }

        .character-btn {
            background: white;
            color: #667eea;
            border: 3px solid #667eea;
            padding: 15px;
            font-size: 1.5em;
            border-radius: 15px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            transition: all 0.3s ease;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .character-btn:hover {
            background: #667eea;
            color: white;
            transform: scale(1.1);
        }

        .game-screen {
            display: none;
        }

        .game-screen.show {
            display: block;
        }

        .menu-screen.hide {
            display: none;
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 2em;
            }
            
            #tracingCanvas {
                width: 100%;
                height: auto;
            }
            
            button {
                padding: 12px 20px;
                font-size: 1em;
                min-width: 120px;
            }

            .character-grid {
                grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
                gap: 8px;
            }

            .character-btn {
                padding: 10px;
                font-size: 1.2em;
            }
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="game-nav">
        <a href="../index.html" class="logo">ðŸŽ® AI Games</a>
    </nav>
    <div class="container">
        <h1>ðŸŒŸ Letter Tracing Game ðŸŒŸ</h1>
        
        <!-- Menu Screen -->
        <div class="menu-screen" id="menuScreen">
            <h2>Choose What to Trace</h2>
            
            <div class="menu-options">
                <button class="menu-btn active" id="lettersBtn">Letters</button>
                <button class="menu-btn" id="numbersBtn">Numbers</button>
            </div>

            <div class="menu-options">
                <button class="menu-btn active" id="uppercaseBtn">Uppercase</button>
                <button class="menu-btn" id="lowercaseBtn">Lowercase</button>
            </div>

            <div class="character-grid" id="characterGrid"></div>
        </div>

        <!-- Game Screen -->
        <div class="game-screen" id="gameScreen">
            <div class="progress-container">
                <div class="progress-bar" id="progressBar">
                    <span id="currentLetter">A</span>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="tracingCanvas" width="400" height="400"></canvas>
                <div class="success-message" id="successMessage">âœ¨ Great Job! âœ¨</div>
            </div>

            <div class="controls">
                <button class="reset-btn" id="resetBtn">Reset</button>
                <button id="backToMenuBtn">Back to Menu</button>
                <button id="nextBtn">Next â†’</button>
            </div>
        </div>
    </div>

    <script>
        // Game state
        const canvas = document.getElementById('tracingCanvas');
        const ctx = canvas.getContext('2d');
        const progressBar = document.getElementById('progressBar');
        const currentLetterSpan = document.getElementById('currentLetter');
        const successMessage = document.getElementById('successMessage');
        const resetBtn = document.getElementById('resetBtn');
        const nextBtn = document.getElementById('nextBtn');
        const backToMenuBtn = document.getElementById('backToMenuBtn');
        
        // Menu elements
        const menuScreen = document.getElementById('menuScreen');
        const gameScreen = document.getElementById('gameScreen');
        const lettersBtn = document.getElementById('lettersBtn');
        const numbersBtn = document.getElementById('numbersBtn');
        const uppercaseBtn = document.getElementById('uppercaseBtn');
        const lowercaseBtn = document.getElementById('lowercaseBtn');
        const characterGrid = document.getElementById('characterGrid');

        // Game state
        let currentCharacter = 'A';
        let currentCharacterIndex = 0; // Index in the current character set
        let isUppercase = true;
        let isLetters = true; // true for letters, false for numbers
        let isDrawing = false;
        let tracedStrokes = []; // Array of strokes, each stroke is an array of points
        let currentStroke = []; // Current stroke being drawn
        let letterPath = [];
        let isComplete = false;
        let canvasSize = 400;

        // Character sets
        const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        const numbers = '0123456789';

        // Letter path definitions - ordered points for each letter
        // Each letter is defined as an array of strokes, each stroke is an array of {x, y} points
        // Points are normalized (0-1) and will be scaled to canvas size
        const letterPaths = {
            'A': [
                [{x: 0.3, y: 0.9}, {x: 0.3, y: 0.5}, {x: 0.5, y: 0.1}],
                [{x: 0.5, y: 0.1}, {x: 0.7, y: 0.5}, {x: 0.7, y: 0.9}],
                [{x: 0.35, y: 0.5}, {x: 0.65, y: 0.5}]
            ],
            'B': [
                [{x: 0.3, y: 0.1}, {x: 0.3, y: 0.9}],
                [{x: 0.3, y: 0.1}, {x: 0.5, y: 0.1}, {x: 0.6, y: 0.2}, {x: 0.6, y: 0.4}, {x: 0.5, y: 0.5}, {x: 0.3, y: 0.5}],
                [{x: 0.3, y: 0.5}, {x: 0.5, y: 0.5}, {x: 0.6, y: 0.6}, {x: 0.6, y: 0.8}, {x: 0.5, y: 0.9}, {x: 0.3, y: 0.9}]
            ],
            'C': [
                [{x: 0.7, y: 0.2}, {x: 0.6, y: 0.1}, {x: 0.4, y: 0.1}, {x: 0.3, y: 0.2}, {x: 0.3, y: 0.8}, {x: 0.4, y: 0.9}, {x: 0.6, y: 0.9}, {x: 0.7, y: 0.8}]
            ],
            'D': [
                [{x: 0.3, y: 0.1}, {x: 0.3, y: 0.9}],
                [{x: 0.3, y: 0.1}, {x: 0.5, y: 0.1}, {x: 0.6, y: 0.3}, {x: 0.6, y: 0.7}, {x: 0.5, y: 0.9}, {x: 0.3, y: 0.9}]
            ],
            'E': [
                [{x: 0.3, y: 0.1}, {x: 0.3, y: 0.9}],
                [{x: 0.3, y: 0.1}, {x: 0.6, y: 0.1}],
                [{x: 0.3, y: 0.5}, {x: 0.55, y: 0.5}],
                [{x: 0.3, y: 0.9}, {x: 0.6, y: 0.9}]
            ],
            'F': [
                [{x: 0.3, y: 0.1}, {x: 0.3, y: 0.9}],
                [{x: 0.3, y: 0.1}, {x: 0.6, y: 0.1}],
                [{x: 0.3, y: 0.5}, {x: 0.55, y: 0.5}]
            ],
            'O': [
                [{x: 0.5, y: 0.2}, {x: 0.4, y: 0.1}, {x: 0.3, y: 0.2}, {x: 0.3, y: 0.5}, {x: 0.3, y: 0.8}, {x: 0.4, y: 0.9}, {x: 0.6, y: 0.9}, {x: 0.7, y: 0.8}, {x: 0.7, y: 0.5}, {x: 0.7, y: 0.2}, {x: 0.6, y: 0.1}, {x: 0.4, y: 0.1}, {x: 0.5, y: 0.2}]
            ],
            // For other letters, will use generatePathFromCanvas fallback
        };

        // Path following state
        let letterCheckpoints = []; // Array of checkpoints for current letter
        let checkpointRadius = 0; // Will be set based on canvas size
        let passedCheckpoints = new Set(); // Track which checkpoints have been passed
        let currentCheckpointIndex = 0; // Current checkpoint to reach

        // Adjust canvas size for mobile
        function resizeCanvas() {
            const container = canvas.parentElement;
            const maxWidth = Math.min(400, container.clientWidth - 40);
            canvasSize = maxWidth;
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            // Reinitialize checkpoints after resize
            if (gameScreen.classList.contains('show')) {
                initializeCheckpoints();
            }
            drawLetter();
        }

        // Menu functions
        function showMenu() {
            menuScreen.classList.remove('hide');
            gameScreen.classList.remove('show');
            updateCharacterGrid();
        }

        function showGame() {
            menuScreen.classList.add('hide');
            gameScreen.classList.add('show');
            updateCurrentCharacter(); // Ensure character is set correctly
            resetLetter();
        }

        // Get current character set
        function getCurrentCharacterSet() {
            return isLetters ? letters : numbers;
        }

        // Update current character based on index
        function updateCurrentCharacter() {
            const charSet = getCurrentCharacterSet();
            const baseChar = charSet[currentCharacterIndex];
            currentCharacter = (isUppercase || !isLetters) ? baseChar : baseChar.toLowerCase();
        }

        function updateCharacterGrid() {
            characterGrid.innerHTML = '';
            const characters = getCurrentCharacterSet();
            
            for (let i = 0; i < characters.length; i++) {
                const char = characters[i];
                const btn = document.createElement('button');
                btn.className = 'character-btn';
                btn.textContent = isUppercase || !isLetters ? char : char.toLowerCase();
                btn.addEventListener('click', () => {
                    currentCharacterIndex = i;
                    updateCurrentCharacter();
                    showGame();
                });
                characterGrid.appendChild(btn);
            }
        }

        // Menu button handlers
        lettersBtn.addEventListener('click', () => {
            isLetters = true;
            currentCharacterIndex = 0; // Reset to first character
            lettersBtn.classList.add('active');
            numbersBtn.classList.remove('active');
            updateCharacterGrid();
        });

        numbersBtn.addEventListener('click', () => {
            isLetters = false;
            currentCharacterIndex = 0; // Reset to first character
            numbersBtn.classList.add('active');
            lettersBtn.classList.remove('active');
            updateCharacterGrid();
        });

        uppercaseBtn.addEventListener('click', () => {
            isUppercase = true;
            updateCurrentCharacter(); // Update current character to uppercase
            uppercaseBtn.classList.add('active');
            lowercaseBtn.classList.remove('active');
            updateCharacterGrid();
        });

        lowercaseBtn.addEventListener('click', () => {
            isUppercase = false;
            updateCurrentCharacter(); // Update current character to lowercase
            lowercaseBtn.classList.add('active');
            uppercaseBtn.classList.remove('active');
            updateCharacterGrid();
        });

        backToMenuBtn.addEventListener('click', showMenu);

        window.addEventListener('resize', resizeCanvas);
        
        // Initialize with menu
        showMenu();

        // Generate checkpoints from letter path
        function generateCheckpoints(letter) {
            const char = letter.toUpperCase();
            let paths = letterPaths[char];
            
            // If letter not in dictionary, generate path from canvas rendering
            if (!paths) {
                paths = generatePathFromCanvas(letter);
            }
            
            // Convert paths to checkpoints with interpolation for smoother detection
            const checkpoints = [];
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = canvasSize * 0.5; // Scale factor for paths - increased for larger letters
            
            for (const stroke of paths) {
                for (let i = 0; i < stroke.length; i++) {
                    const point = stroke[i];
                    const x = centerX + (point.x - 0.5) * scale * 2;
                    const y = centerY + (point.y - 0.5) * scale * 2;
                    
                    // Add the main checkpoint
                    checkpoints.push({
                        x: x,
                        y: y,
                        strokeIndex: paths.indexOf(stroke),
                        pointIndex: i
                    });
                    
                    // Add intermediate checkpoints between points for better detection
                    if (i < stroke.length - 1) {
                        const nextPoint = stroke[i + 1];
                        const nextX = centerX + (nextPoint.x - 0.5) * scale * 2;
                        const nextY = centerY + (nextPoint.y - 0.5) * scale * 2;
                        
                        // Add 2-3 intermediate points
                        const numIntermediate = 2;
                        for (let j = 1; j <= numIntermediate; j++) {
                            const t = j / (numIntermediate + 1);
                            checkpoints.push({
                                x: x + (nextX - x) * t,
                                y: y + (nextY - y) * t,
                                strokeIndex: paths.indexOf(stroke),
                                pointIndex: i + t
                            });
                        }
                    }
                }
            }
            
            return checkpoints;
        }

        // Generate path from canvas rendering (fallback for letters not in dictionary)
        function generatePathFromCanvas(letter) {
            // Create temp canvas to extract letter outline
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = 100;
            tempCanvas.height = 100;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.font = 'bold 60px Arial';
            tempCtx.textAlign = 'center';
            tempCtx.textBaseline = 'middle';
            tempCtx.fillStyle = 'black';
            tempCtx.fillText(letter, 50, 50);
            
            // Extract edge points
            const imageData = tempCtx.getImageData(0, 0, 100, 100);
            const data = imageData.data;
            const edgePoints = [];
            
            // Find edge pixels
            for (let y = 1; y < 99; y++) {
                for (let x = 1; x < 99; x++) {
                    const index = (y * 100 + x) * 4;
                    if (data[index + 3] > 128) {
                        // Check if it's an edge
                        let isEdge = false;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const nIndex = ((y + dy) * 100 + (x + dx)) * 4;
                                if (data[nIndex + 3] < 128) {
                                    isEdge = true;
                                    break;
                                }
                            }
                            if (isEdge) break;
                        }
                        if (isEdge) {
                            edgePoints.push({x: x / 100, y: y / 100});
                        }
                    }
                }
            }
            
            // Group edge points into strokes (simplified - just return as one stroke)
            if (edgePoints.length > 0) {
                // Sort points to create a path
                return [edgePoints.slice(0, Math.min(50, edgePoints.length))];
            }
            
            // Fallback: simple path
            return [[{x: 0.3, y: 0.1}, {x: 0.7, y: 0.1}, {x: 0.7, y: 0.9}, {x: 0.3, y: 0.9}, {x: 0.3, y: 0.1}]];
        }

        // Initialize checkpoints for current letter
        function initializeCheckpoints() {
            letterCheckpoints = generateCheckpoints(currentCharacter);
            // Checkpoint radius - larger to account for brush stroke width
            checkpointRadius = Math.max(25, canvasSize * 0.06); // Increased for better detection
            passedCheckpoints.clear();
            currentCheckpointIndex = 0;
        }

        // Check if user is near a checkpoint - more forgiving
        function checkCheckpointProximity(point) {
            if (letterCheckpoints.length === 0) return false;
            
            // Check current checkpoint and a few ahead
            const lookAhead = 3;
            let foundCheckpoint = false;
            
            for (let i = currentCheckpointIndex; i < Math.min(currentCheckpointIndex + lookAhead, letterCheckpoints.length); i++) {
                const checkpoint = letterCheckpoints[i];
                const dx = point.x - checkpoint.x;
                const dy = point.y - checkpoint.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist <= checkpointRadius) {
                    // Mark as passed and advance
                    passedCheckpoints.add(i);
                    if (i >= currentCheckpointIndex) {
                        // Advance to next unchecked checkpoint
                        currentCheckpointIndex = Math.max(currentCheckpointIndex, i + 1);
                        foundCheckpoint = true;
                    }
                }
            }
            
            return foundCheckpoint;
        }

        // Draw the letter/number
        function drawLetter() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const letter = currentCharacter;
            
            // Set up text style - larger letter for path-following algorithm
            ctx.font = `bold ${canvasSize * 0.75}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            ctx.save();
            
            // Draw a light filled letter as guide (no dots)
            ctx.fillStyle = 'rgba(255, 107, 157, 0.2)';
            ctx.fillText(letter, canvas.width / 2, canvas.height / 2);
            
            // Draw checkpoints (small circles along the path)
            if (letterCheckpoints.length > 0) {
                for (let i = 0; i < letterCheckpoints.length; i++) {
                    const checkpoint = letterCheckpoints[i];
                    const isPassed = passedCheckpoints.has(i);
                    const isNext = i === currentCheckpointIndex;
                    
                    ctx.beginPath();
                    ctx.arc(checkpoint.x, checkpoint.y, isNext ? 8 : 5, 0, Math.PI * 2);
                    ctx.fillStyle = isPassed ? '#2ecc71' : (isNext ? '#feca57' : 'rgba(255, 107, 157, 0.5)');
                    ctx.fill();
                }
            }
            
            // Store letter path for collision detection
            storeLetterPath(letter);
            
            // Draw all traced strokes separately (so they don't connect)
            ctx.lineWidth = canvasSize * 0.08; // Brush stroke width
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // Draw completed strokes
            for (const stroke of tracedStrokes) {
                if (stroke.length > 0) {
                    const lastPoint = stroke[stroke.length - 1];
                    const isOnLetter = isPointOnLetter(lastPoint.x, lastPoint.y);
                    ctx.strokeStyle = isOnLetter ? '#2ecc71' : '#4ecdc4';
                    
                    ctx.beginPath();
                    ctx.moveTo(stroke[0].x, stroke[0].y);
                    for (let i = 1; i < stroke.length; i++) {
                        ctx.lineTo(stroke[i].x, stroke[i].y);
                    }
                    ctx.stroke();
                }
            }
            
            // Draw current stroke being drawn
            if (currentStroke.length > 0) {
                const lastPoint = currentStroke[currentStroke.length - 1];
                const isOnLetter = isPointOnLetter(lastPoint.x, lastPoint.y);
                ctx.strokeStyle = isOnLetter ? '#2ecc71' : '#4ecdc4';
                
                ctx.beginPath();
                ctx.moveTo(currentStroke[0].x, currentStroke[0].y);
                for (let i = 1; i < currentStroke.length; i++) {
                    ctx.lineTo(currentStroke[i].x, currentStroke[i].y);
                }
                ctx.stroke();
            }
            
            ctx.restore();
        }

        // Store letter path for collision detection
        function storeLetterPath(letter) {
            // Create a temporary canvas to get the letter's pixel data
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCtx.font = `bold ${canvasSize * 0.75}px Arial`;
            tempCtx.textAlign = 'center';
            tempCtx.textBaseline = 'middle';
            tempCtx.fillStyle = 'black';
            tempCtx.fillText(letter, canvas.width / 2, canvas.height / 2);
            
            letterPath = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
        }

        // Check if point is on the letter
        function isPointOnLetter(x, y) {
            if (!letterPath) return false;
            
            const pixelX = Math.floor(x);
            const pixelY = Math.floor(y);
            
            if (pixelX < 0 || pixelX >= canvas.width || pixelY < 0 || pixelY >= canvas.height) {
                return false;
            }
            
            const index = (pixelY * canvas.width + pixelX) * 4;
            const alpha = letterPath.data[index + 3];
            
            return alpha > 128; // Threshold for detecting the letter
        }

        // Get mouse/touch position relative to canvas
        function getEventPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            if (e.touches) {
                return {
                    x: (e.touches[0].clientX - rect.left) * scaleX,
                    y: (e.touches[0].clientY - rect.top) * scaleY
                };
            } else {
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            }
        }

        // Start drawing
        function startDrawing(e) {
            e.preventDefault();
            if (isComplete) return;
            
            isDrawing = true;
            const pos = getEventPos(e);
            
            // Start a new stroke (don't connect to previous strokes)
            currentStroke = [pos];
            drawLetter();
        }

        // Continue drawing
        function continueDrawing(e) {
            e.preventDefault();
            if (!isDrawing || isComplete) return;
            
            const pos = getEventPos(e);
            currentStroke.push(pos);
            
            // Check if we're near a checkpoint (path following)
            if (letterCheckpoints.length > 0) {
                checkCheckpointProximity(pos);
                checkCompletion();
            } else {
                // Fallback to old method if no checkpoints
                if (isPointOnLetter(pos.x, pos.y)) {
                    checkCompletion();
                }
            }
            
            drawLetter();
        }

        // Stop drawing
        function stopDrawing(e) {
            e.preventDefault();
            if (!isDrawing) return;
            
            isDrawing = false;
            
            // Save the current stroke to the strokes array
            if (currentStroke.length > 0) {
                tracedStrokes.push([...currentStroke]);
                currentStroke = [];
            }
            
            checkCompletion();
            drawLetter();
        }

        // Check if tracing is complete - using geometry-based path following
        function checkCompletion() {
            if (isComplete) return;
            
            // Use path-following algorithm if checkpoints are available
            if (letterCheckpoints.length > 0) {
                const totalCheckpoints = letterCheckpoints.length;
                const passedCount = passedCheckpoints.size;
                
                // Check sequential progress - require checkpoints to be passed in order
                // Count how many consecutive checkpoints from the start have been passed
                let consecutivePassed = 0;
                for (let i = 0; i < totalCheckpoints; i++) {
                    if (passedCheckpoints.has(i)) {
                        consecutivePassed++;
                    } else {
                        break; // Stop at first gap
                    }
                }
                
                // Also check if we've reached near the end (allow some gaps but must reach far)
                const maxReachedIndex = Math.max(...Array.from(passedCheckpoints), -1);
                const reachedEnd = maxReachedIndex >= totalCheckpoints * 0.7; // Must reach 70% of the way
                
                const coverageRatio = passedCount / totalCheckpoints;
                const sequentialRatio = consecutivePassed / totalCheckpoints;
                
                // More lenient requirements - balance between accuracy and achievability
                const minCheckpointCoverage = 0.6; // 60% coverage
                const minSequentialRatio = 0.5; // At least 50% must be consecutive from start
                
                // Also check path length to ensure substantial tracing
                let pathLength = 0;
                for (const stroke of tracedStrokes) {
                    for (let i = 1; i < stroke.length; i++) {
                        const dx = stroke[i].x - stroke[i-1].x;
                        const dy = stroke[i].y - stroke[i-1].y;
                        pathLength += Math.sqrt(dx * dx + dy * dy);
                    }
                }
                for (let i = 1; i < currentStroke.length; i++) {
                    const dx = currentStroke[i].x - currentStroke[i-1].x;
                    const dy = currentStroke[i].y - currentStroke[i-1].y;
                    pathLength += Math.sqrt(dx * dx + dy * dy);
                }
                
                const minPathLength = canvasSize * 0.25; // Reasonable path length
                
                console.log('Path Following - Total passed:', passedCount + '/' + totalCheckpoints,
                           'Consecutive from start:', consecutivePassed,
                           'Max reached index:', maxReachedIndex + '/' + totalCheckpoints,
                           'Coverage:', (coverageRatio * 100).toFixed(1) + '%',
                           'Sequential:', (sequentialRatio * 100).toFixed(1) + '%',
                           'Path length:', pathLength.toFixed(0),
                           'âœ“ Coverage:', coverageRatio >= minCheckpointCoverage ? 'YES' : 'NO',
                           'âœ“ Sequential:', sequentialRatio >= minSequentialRatio ? 'YES' : 'NO',
                           'âœ“ Reached end:', reachedEnd ? 'YES' : 'NO',
                           'âœ“ Path length:', pathLength >= minPathLength ? 'YES' : 'NO');
                
                // Complete if:
                // 1. Good total coverage (60%+) OR good sequential progress (50%+)
                // 2. Reached near the end of the path (70%+)
                // 3. Sufficient path length
                // More lenient - allows completion if either coverage or sequential is good
                if ((coverageRatio >= minCheckpointCoverage || sequentialRatio >= minSequentialRatio) &&
                    reachedEnd &&
                    pathLength >= minPathLength) {
                    completeTracing();
                }
            } else {
                // Fallback to old method if no checkpoints available
                if (!letterPath) return;
                // Simple check - just verify some tracing happened
                const allPoints = [];
                for (const stroke of tracedStrokes) {
                    allPoints.push(...stroke);
                }
                allPoints.push(...currentStroke);
                
                if (allPoints.length > 50) {
                    // Basic completion - can be improved
                    let pointsOnLetter = 0;
                    for (let i = 0; i < allPoints.length; i += 5) {
                        if (isPointOnLetter(allPoints[i].x, allPoints[i].y)) {
                            pointsOnLetter++;
                        }
                    }
                    if (pointsOnLetter / (allPoints.length / 5) > 0.6) {
                        completeTracing();
                    }
                }
            }
        }

        // Complete tracing with animation
        function completeTracing() {
            isComplete = true;
            successMessage.classList.add('show');
            
            // Create sparkle stars
            createSparkles();
            
            // Hide success message after animation
            setTimeout(() => {
                successMessage.classList.remove('show');
            }, 2000);
            
            // Automatically move to next letter after delay
            setTimeout(() => {
                nextLetter();
            }, 2500); // 2.5 seconds - allows time to see the success message
            
            // Enable next button (user can still click it manually if they want)
            nextBtn.disabled = false;
        }

        // Create sparkle animation
        function createSparkles() {
            const container = canvas.parentElement;
            const numStars = 15;
            
            for (let i = 0; i < numStars; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.textContent = 'â­';
                
                const angle = (Math.PI * 2 * i) / numStars;
                const radius = canvasSize * 0.4;
                const x = canvas.width / 2 + Math.cos(angle) * radius;
                const y = canvas.height / 2 + Math.sin(angle) * radius;
                
                star.style.left = (x / canvas.width * 100) + '%';
                star.style.top = (y / canvas.height * 100) + '%';
                
                container.appendChild(star);
                
                setTimeout(() => {
                    star.remove();
                }, 1000);
            }
        }

        // Update progress bar
        function updateProgress() {
            currentLetterSpan.textContent = currentCharacter;
        }

        // Reset current letter
        function resetLetter() {
            tracedStrokes = [];
            currentStroke = [];
            isComplete = false;
            isDrawing = false;
            nextBtn.disabled = true;
            successMessage.classList.remove('show');
            updateProgress();
            if (gameScreen.classList.contains('show')) {
                resizeCanvas();
                // Initialize checkpoints after canvas is ready
                setTimeout(() => initializeCheckpoints(), 100);
            }
        }

        // Move to next character (cycle through)
        function nextLetter() {
            const charSet = getCurrentCharacterSet();
            // Move to next index, wrap around to 0 if at the end
            currentCharacterIndex = (currentCharacterIndex + 1) % charSet.length;
            updateCurrentCharacter();
            resetLetter();
        }

        // Event listeners
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', continueDrawing);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseleave', stopDrawing);

        canvas.addEventListener('touchstart', startDrawing, { passive: false });
        canvas.addEventListener('touchmove', continueDrawing, { passive: false });
        canvas.addEventListener('touchend', stopDrawing, { passive: false });
        canvas.addEventListener('touchcancel', stopDrawing, { passive: false });

        resetBtn.addEventListener('click', resetLetter);
        nextBtn.addEventListener('click', nextLetter);
    </script>
</body>
</html>

