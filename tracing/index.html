<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Letter Tracing Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', 'Arial Rounded MT Bold', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow-x: hidden;
        }

        .container {
            background: white;
            border-radius: 30px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            width: 100%;
            text-align: center;
        }

        h1 {
            color: #ff6b9d;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .progress-container {
            margin: 20px 0;
            background: #f0f0f0;
            border-radius: 20px;
            padding: 10px;
            position: relative;
            width: 100%;
            height: 50px;
        }

        .progress-bar {
            background: linear-gradient(90deg, #4ecdc4, #44a08d);
            height: 30px;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 1.5em;
            width: 100%;
            min-width: 120px;
        }

        .canvas-container {
            position: relative;
            margin: 30px auto;
            background: #f9f9f9;
            border-radius: 20px;
            padding: 20px;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        #tracingCanvas {
            display: block;
            margin: 0 auto;
            cursor: crosshair;
            touch-action: none;
            border-radius: 10px;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        button {
            background: linear-gradient(135deg, #ff6b9d, #ff8fab);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2em;
            border-radius: 25px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(255, 107, 157, 0.4);
            transition: all 0.3s ease;
            min-width: 150px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 157, 0.6);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            box-shadow: none;
        }

        .toggle-btn {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.4);
        }

        .toggle-btn:hover {
            box-shadow: 0 6px 20px rgba(78, 205, 196, 0.6);
        }

        .reset-btn {
            background: linear-gradient(135deg, #feca57, #ff9ff3);
            box-shadow: 0 4px 15px rgba(254, 202, 87, 0.4);
        }

        .reset-btn:hover {
            box-shadow: 0 6px 20px rgba(254, 202, 87, 0.6);
        }

        .success-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3em;
            color: #4ecdc4;
            font-weight: bold;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 10;
        }

        .success-message.show {
            opacity: 1;
            animation: bounce 0.6s ease;
        }

        @keyframes bounce {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
        }

        /* Star animation for success */
        .star {
            position: absolute;
            color: #ffd700;
            font-size: 2em;
            pointer-events: none;
            animation: sparkle 1s ease-out forwards;
        }

        @keyframes sparkle {
            0% {
                opacity: 1;
                transform: scale(0) rotate(0deg);
            }
            100% {
                opacity: 0;
                transform: scale(1.5) rotate(360deg);
            }
        }

        /* Menu styles */
        .menu-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .menu-options {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin: 20px 0;
        }

        .menu-btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 15px 25px;
            font-size: 1.1em;
            border-radius: 20px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            transition: all 0.3s ease;
        }

        .menu-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .menu-btn.active {
            background: linear-gradient(135deg, #ff6b9d, #ff8fab);
            box-shadow: 0 4px 15px rgba(255, 107, 157, 0.4);
        }

        .character-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
            gap: 10px;
            max-width: 500px;
            width: 100%;
            margin: 20px 0;
        }

        .character-btn {
            background: white;
            color: #667eea;
            border: 3px solid #667eea;
            padding: 15px;
            font-size: 1.5em;
            border-radius: 15px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            transition: all 0.3s ease;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .character-btn:hover {
            background: #667eea;
            color: white;
            transform: scale(1.1);
        }

        .game-screen {
            display: none;
        }

        .game-screen.show {
            display: block;
        }

        .menu-screen.hide {
            display: none;
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 2em;
            }
            
            #tracingCanvas {
                width: 100%;
                height: auto;
            }
            
            button {
                padding: 12px 20px;
                font-size: 1em;
                min-width: 120px;
            }

            .character-grid {
                grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
                gap: 8px;
            }

            .character-btn {
                padding: 10px;
                font-size: 1.2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŒŸ Letter Tracing Game ðŸŒŸ</h1>
        
        <!-- Menu Screen -->
        <div class="menu-screen" id="menuScreen">
            <h2>Choose What to Trace</h2>
            
            <div class="menu-options">
                <button class="menu-btn active" id="lettersBtn">Letters</button>
                <button class="menu-btn" id="numbersBtn">Numbers</button>
            </div>

            <div class="menu-options">
                <button class="menu-btn active" id="uppercaseBtn">Uppercase</button>
                <button class="menu-btn" id="lowercaseBtn">Lowercase</button>
            </div>

            <div class="character-grid" id="characterGrid"></div>
        </div>

        <!-- Game Screen -->
        <div class="game-screen" id="gameScreen">
            <div class="progress-container">
                <div class="progress-bar" id="progressBar">
                    <span id="currentLetter">A</span>
                </div>
            </div>

            <div class="canvas-container">
                <canvas id="tracingCanvas" width="400" height="400"></canvas>
                <div class="success-message" id="successMessage">âœ¨ Great Job! âœ¨</div>
            </div>

            <div class="controls">
                <button class="reset-btn" id="resetBtn">Reset</button>
                <button id="backToMenuBtn">Back to Menu</button>
                <button id="nextBtn">Next â†’</button>
            </div>
        </div>
    </div>

    <script>
        // Game state
        const canvas = document.getElementById('tracingCanvas');
        const ctx = canvas.getContext('2d');
        const progressBar = document.getElementById('progressBar');
        const currentLetterSpan = document.getElementById('currentLetter');
        const successMessage = document.getElementById('successMessage');
        const resetBtn = document.getElementById('resetBtn');
        const nextBtn = document.getElementById('nextBtn');
        const backToMenuBtn = document.getElementById('backToMenuBtn');
        
        // Menu elements
        const menuScreen = document.getElementById('menuScreen');
        const gameScreen = document.getElementById('gameScreen');
        const lettersBtn = document.getElementById('lettersBtn');
        const numbersBtn = document.getElementById('numbersBtn');
        const uppercaseBtn = document.getElementById('uppercaseBtn');
        const lowercaseBtn = document.getElementById('lowercaseBtn');
        const characterGrid = document.getElementById('characterGrid');

        // Game state
        let currentCharacter = 'A';
        let currentCharacterIndex = 0; // Index in the current character set
        let isUppercase = true;
        let isLetters = true; // true for letters, false for numbers
        let isDrawing = false;
        let tracedStrokes = []; // Array of strokes, each stroke is an array of points
        let currentStroke = []; // Current stroke being drawn
        let letterPath = [];
        let isComplete = false;
        let canvasSize = 400;

        // Character sets
        const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        const numbers = '0123456789';

        // Letter path definitions - ordered points for each letter
        // Each letter is defined as an array of strokes, each stroke is an array of {x, y} points
        // Points are normalized (0-1) and will be scaled to canvas size
        const letterPaths = {
            'A': [
                // Left stroke
                [{x: 0.3, y: 0.9}, {x: 0.3, y: 0.5}, {x: 0.5, y: 0.1}],
                // Right stroke
                [{x: 0.5, y: 0.1}, {x: 0.7, y: 0.5}, {x: 0.7, y: 0.9}],
                // Crossbar
                [{x: 0.35, y: 0.5}, {x: 0.65, y: 0.5}]
            ],
            'B': [
                // Left vertical
                [{x: 0.3, y: 0.1}, {x: 0.3, y: 0.9}],
                // Top curve
                [{x: 0.3, y: 0.1}, {x: 0.5, y: 0.1}, {x: 0.6, y: 0.2}, {x: 0.6, y: 0.4}, {x: 0.5, y: 0.5}, {x: 0.3, y: 0.5}],
                // Bottom curve
                [{x: 0.3, y: 0.5}, {x: 0.5, y: 0.5}, {x: 0.6, y: 0.6}, {x: 0.6, y: 0.8}, {x: 0.5, y: 0.9}, {x: 0.3, y: 0.9}]
            ],
            // Add more letters as needed - for now, use a generic path generator
        };

        // Path following state
        let letterCheckpoints = []; // Array of checkpoints for current letter
        let checkpointRadius = 0; // Will be set based on canvas size
        let passedCheckpoints = new Set(); // Track which checkpoints have been passed
        let currentCheckpointIndex = 0; // Current checkpoint to reach

        // Adjust canvas size for mobile
        function resizeCanvas() {
            const container = canvas.parentElement;
            const maxWidth = Math.min(400, container.clientWidth - 40);
            canvasSize = maxWidth;
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            drawLetter();
        }

        // Menu functions
        function showMenu() {
            menuScreen.classList.remove('hide');
            gameScreen.classList.remove('show');
            updateCharacterGrid();
        }

        function showGame() {
            menuScreen.classList.add('hide');
            gameScreen.classList.add('show');
            updateCurrentCharacter(); // Ensure character is set correctly
            resetLetter();
        }

        // Get current character set
        function getCurrentCharacterSet() {
            return isLetters ? letters : numbers;
        }

        // Update current character based on index
        function updateCurrentCharacter() {
            const charSet = getCurrentCharacterSet();
            const baseChar = charSet[currentCharacterIndex];
            currentCharacter = (isUppercase || !isLetters) ? baseChar : baseChar.toLowerCase();
        }

        function updateCharacterGrid() {
            characterGrid.innerHTML = '';
            const characters = getCurrentCharacterSet();
            
            for (let i = 0; i < characters.length; i++) {
                const char = characters[i];
                const btn = document.createElement('button');
                btn.className = 'character-btn';
                btn.textContent = isUppercase || !isLetters ? char : char.toLowerCase();
                btn.addEventListener('click', () => {
                    currentCharacterIndex = i;
                    updateCurrentCharacter();
                    showGame();
                });
                characterGrid.appendChild(btn);
            }
        }

        // Menu button handlers
        lettersBtn.addEventListener('click', () => {
            isLetters = true;
            currentCharacterIndex = 0; // Reset to first character
            lettersBtn.classList.add('active');
            numbersBtn.classList.remove('active');
            updateCharacterGrid();
        });

        numbersBtn.addEventListener('click', () => {
            isLetters = false;
            currentCharacterIndex = 0; // Reset to first character
            numbersBtn.classList.add('active');
            lettersBtn.classList.remove('active');
            updateCharacterGrid();
        });

        uppercaseBtn.addEventListener('click', () => {
            isUppercase = true;
            updateCurrentCharacter(); // Update current character to uppercase
            uppercaseBtn.classList.add('active');
            lowercaseBtn.classList.remove('active');
            updateCharacterGrid();
        });

        lowercaseBtn.addEventListener('click', () => {
            isUppercase = false;
            updateCurrentCharacter(); // Update current character to lowercase
            lowercaseBtn.classList.add('active');
            uppercaseBtn.classList.remove('active');
            updateCharacterGrid();
        });

        backToMenuBtn.addEventListener('click', showMenu);

        window.addEventListener('resize', resizeCanvas);
        
        // Initialize with menu
        showMenu();

        // Draw the letter/number
        function drawLetter() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const letter = currentCharacter;
            
            // Set up text style
            ctx.font = `bold ${canvasSize * 0.6}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            ctx.save();
            
            // Draw a light filled letter as guide (no dots)
            ctx.fillStyle = 'rgba(255, 107, 157, 0.2)';
            ctx.fillText(letter, canvas.width / 2, canvas.height / 2);
            
            // Store letter path for collision detection
            storeLetterPath(letter);
            
            // Draw all traced strokes separately (so they don't connect)
            ctx.lineWidth = canvasSize * 0.12; // Thicker brush stroke for better visibility
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // Draw completed strokes
            for (const stroke of tracedStrokes) {
                if (stroke.length > 0) {
                    const lastPoint = stroke[stroke.length - 1];
                    const isOnLetter = isPointOnLetter(lastPoint.x, lastPoint.y);
                    ctx.strokeStyle = isOnLetter ? '#2ecc71' : '#4ecdc4';
                    
                    ctx.beginPath();
                    ctx.moveTo(stroke[0].x, stroke[0].y);
                    for (let i = 1; i < stroke.length; i++) {
                        ctx.lineTo(stroke[i].x, stroke[i].y);
                    }
                    ctx.stroke();
                }
            }
            
            // Draw current stroke being drawn
            if (currentStroke.length > 0) {
                const lastPoint = currentStroke[currentStroke.length - 1];
                const isOnLetter = isPointOnLetter(lastPoint.x, lastPoint.y);
                ctx.strokeStyle = isOnLetter ? '#2ecc71' : '#4ecdc4';
                
                ctx.beginPath();
                ctx.moveTo(currentStroke[0].x, currentStroke[0].y);
                for (let i = 1; i < currentStroke.length; i++) {
                    ctx.lineTo(currentStroke[i].x, currentStroke[i].y);
                }
                ctx.stroke();
            }
            
            ctx.restore();
        }

        // Store letter path for collision detection
        function storeLetterPath(letter) {
            // Create a temporary canvas to get the letter's pixel data
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCtx.font = `bold ${canvasSize * 0.6}px Arial`;
            tempCtx.textAlign = 'center';
            tempCtx.textBaseline = 'middle';
            tempCtx.fillStyle = 'black';
            tempCtx.fillText(letter, canvas.width / 2, canvas.height / 2);
            
            letterPath = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
        }

        // Check if point is on the letter
        function isPointOnLetter(x, y) {
            if (!letterPath) return false;
            
            const pixelX = Math.floor(x);
            const pixelY = Math.floor(y);
            
            if (pixelX < 0 || pixelX >= canvas.width || pixelY < 0 || pixelY >= canvas.height) {
                return false;
            }
            
            const index = (pixelY * canvas.width + pixelX) * 4;
            const alpha = letterPath.data[index + 3];
            
            return alpha > 128; // Threshold for detecting the letter
        }

        // Get mouse/touch position relative to canvas
        function getEventPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            if (e.touches) {
                return {
                    x: (e.touches[0].clientX - rect.left) * scaleX,
                    y: (e.touches[0].clientY - rect.top) * scaleY
                };
            } else {
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            }
        }

        // Start drawing
        function startDrawing(e) {
            e.preventDefault();
            if (isComplete) return;
            
            isDrawing = true;
            const pos = getEventPos(e);
            
            // Start a new stroke (don't connect to previous strokes)
            currentStroke = [pos];
            drawLetter();
        }

        // Continue drawing
        function continueDrawing(e) {
            e.preventDefault();
            if (!isDrawing || isComplete) return;
            
            const pos = getEventPos(e);
            currentStroke.push(pos);
            
            // Check if we're tracing over the letter
            if (isPointOnLetter(pos.x, pos.y)) {
                checkCompletion();
            }
            
            drawLetter();
        }

        // Stop drawing
        function stopDrawing(e) {
            e.preventDefault();
            if (!isDrawing) return;
            
            isDrawing = false;
            
            // Save the current stroke to the strokes array
            if (currentStroke.length > 0) {
                tracedStrokes.push([...currentStroke]);
                currentStroke = [];
            }
            
            checkCompletion();
            drawLetter();
        }

        // Check if tracing is complete - using region-based detection
        function checkCompletion() {
            if (isComplete || !letterPath) return;
            
            // Combine all strokes (completed + current) into one array for checking
            const allPoints = [];
            for (const stroke of tracedStrokes) {
                allPoints.push(...stroke);
            }
            allPoints.push(...currentStroke);
            
            if (allPoints.length < 80) return; // Require more points to prevent early triggers
            
            const data = letterPath.data;
            
            // Method: Divide letter into regions and check if each region is covered
            // This prevents partial tracing from triggering completion
            
            // Find letter bounds
            let minX = canvas.width, maxX = 0, minY = canvas.height, maxY = 0;
            let hasLetter = false;
            
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const index = (y * canvas.width + x) * 4;
                    if (index + 3 < data.length && data[index + 3] > 128) {
                        hasLetter = true;
                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                    }
                }
            }
            
            if (!hasLetter) return;
            
            const letterWidth = maxX - minX;
            const letterHeight = maxY - minY;
            
            // Divide letter into 9 regions (3x3 grid)
            const regions = [];
            const regionWidth = letterWidth / 3;
            const regionHeight = letterHeight / 3;
            
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    regions.push({
                        minX: minX + col * regionWidth,
                        maxX: minX + (col + 1) * regionWidth,
                        minY: minY + row * regionHeight,
                        maxY: minY + (row + 1) * regionHeight,
                        totalPixels: 0,
                        coveredPixels: 0
                    });
                }
            }
            
            // Sample traced points
            const tracedPointsSet = [];
            const traceSampleStep = Math.max(1, Math.floor(allPoints.length / 150));
            for (let i = 0; i < allPoints.length; i += traceSampleStep) {
                tracedPointsSet.push(allPoints[i]);
            }
            
            // Adjust trace radius to match thicker brush stroke (12% of canvas)
            // Use half the brush width as the detection radius
            const traceRadius = Math.max(15, canvasSize * 0.06); // Matches brush stroke thickness
            const sampleRate = 3;
            
            // Check each region
            for (const region of regions) {
                for (let y = region.minY; y < region.maxY; y += sampleRate) {
                    for (let x = region.minX; x < region.maxX; x += sampleRate) {
                        const px = Math.floor(x);
                        const py = Math.floor(y);
                        if (px >= 0 && px < canvas.width && py >= 0 && py < canvas.height) {
                            const index = (py * canvas.width + px) * 4;
                            if (index + 3 < data.length && data[index + 3] > 128) {
                                region.totalPixels++;
                                
                                // Check if covered
                                for (const point of tracedPointsSet) {
                                    const dx = point.x - px;
                                    const dy = point.y - py;
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    if (dist <= traceRadius) {
                                        region.coveredPixels++;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Calculate coverage for each region
            // Adjusted for thicker brush stroke - need higher coverage per region
            let regionsWithGoodCoverage = 0;
            let totalCoverage = 0;
            const minRegionCoverage = 0.6; // Increased to 60% - thicker brush covers more easily
            
            for (const region of regions) {
                if (region.totalPixels > 0) {
                    const regionCoverage = region.coveredPixels / region.totalPixels;
                    totalCoverage += regionCoverage;
                    if (regionCoverage >= minRegionCoverage) {
                        regionsWithGoodCoverage++;
                    }
                }
            }
            
            const avgCoverage = totalCoverage / regions.length;
            const regionCoverageRatio = regionsWithGoodCoverage / regions.length;
            
            // Calculate path length
            let pathLength = 0;
            for (const stroke of tracedStrokes) {
                for (let i = 1; i < stroke.length; i++) {
                    const dx = stroke[i].x - stroke[i-1].x;
                    const dy = stroke[i].y - stroke[i-1].y;
                    pathLength += Math.sqrt(dx * dx + dy * dy);
                }
            }
            for (let i = 1; i < currentStroke.length; i++) {
                const dx = currentStroke[i].x - currentStroke[i-1].x;
                const dy = currentStroke[i].y - currentStroke[i-1].y;
                pathLength += Math.sqrt(dx * dx + dy * dy);
            }
            
            // Adjusted path length requirement for thicker brush
            const minPathLength = canvasSize * 0.25; // Slightly lower since thicker brush covers more
            
            // Debug info
            console.log('Regions covered:', regionsWithGoodCoverage + '/9',
                       'Region coverage ratio:', (regionCoverageRatio * 100).toFixed(1) + '%',
                       'Avg coverage:', (avgCoverage * 100).toFixed(1) + '%',
                       'Path length:', pathLength.toFixed(0),
                       'Min path:', minPathLength.toFixed(0),
                       'Brush width:', (canvasSize * 0.12).toFixed(0) + 'px');
            
            // Complete only if:
            // 1. At least 7 out of 9 regions have good coverage (stricter for thicker brush)
            // 2. Average coverage is high (75%+) - thicker brush should achieve this easily
            // 3. Path length is sufficient
            // Adjusted thresholds to account for thicker brush covering more area
            if (regionsWithGoodCoverage >= 7 && 
                avgCoverage >= 0.75 && 
                pathLength >= minPathLength) {
                completeTracing();
            }
        }

        // Complete tracing with animation
        function completeTracing() {
            isComplete = true;
            successMessage.classList.add('show');
            
            // Create sparkle stars
            createSparkles();
            
            // Hide success message after animation
            setTimeout(() => {
                successMessage.classList.remove('show');
            }, 2000);
            
            // Automatically move to next letter after delay
            setTimeout(() => {
                nextLetter();
            }, 2500); // 2.5 seconds - allows time to see the success message
            
            // Enable next button (user can still click it manually if they want)
            nextBtn.disabled = false;
        }

        // Create sparkle animation
        function createSparkles() {
            const container = canvas.parentElement;
            const numStars = 15;
            
            for (let i = 0; i < numStars; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.textContent = 'â­';
                
                const angle = (Math.PI * 2 * i) / numStars;
                const radius = canvasSize * 0.4;
                const x = canvas.width / 2 + Math.cos(angle) * radius;
                const y = canvas.height / 2 + Math.sin(angle) * radius;
                
                star.style.left = (x / canvas.width * 100) + '%';
                star.style.top = (y / canvas.height * 100) + '%';
                
                container.appendChild(star);
                
                setTimeout(() => {
                    star.remove();
                }, 1000);
            }
        }

        // Update progress bar
        function updateProgress() {
            currentLetterSpan.textContent = currentCharacter;
        }

        // Reset current letter
        function resetLetter() {
            tracedStrokes = [];
            currentStroke = [];
            isComplete = false;
            isDrawing = false;
            nextBtn.disabled = true;
            successMessage.classList.remove('show');
            updateProgress();
            if (gameScreen.classList.contains('show')) {
                resizeCanvas();
            }
        }

        // Move to next character (cycle through)
        function nextLetter() {
            const charSet = getCurrentCharacterSet();
            // Move to next index, wrap around to 0 if at the end
            currentCharacterIndex = (currentCharacterIndex + 1) % charSet.length;
            updateCurrentCharacter();
            resetLetter();
        }

        // Event listeners
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', continueDrawing);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseleave', stopDrawing);

        canvas.addEventListener('touchstart', startDrawing, { passive: false });
        canvas.addEventListener('touchmove', continueDrawing, { passive: false });
        canvas.addEventListener('touchend', stopDrawing, { passive: false });
        canvas.addEventListener('touchcancel', stopDrawing, { passive: false });

        resetBtn.addEventListener('click', resetLetter);
        nextBtn.addEventListener('click', nextLetter);
    </script>
</body>
</html>

