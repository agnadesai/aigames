<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Letter Tracing Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', 'Arial Rounded MT Bold', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow-x: hidden;
        }

        .container {
            background: white;
            border-radius: 30px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 600px;
            width: 100%;
            text-align: center;
        }

        h1 {
            color: #ff6b9d;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .progress-container {
            margin: 20px 0;
            background: #f0f0f0;
            border-radius: 20px;
            padding: 10px;
            position: relative;
            width: 100%;
            height: 50px;
        }

        .progress-bar {
            background: linear-gradient(90deg, #4ecdc4, #44a08d);
            height: 30px;
            border-radius: 15px;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 1.1em;
            width: 3.85%; /* Start at 1/26 */
            min-width: 120px;
        }

        .canvas-container {
            position: relative;
            margin: 30px auto;
            background: #f9f9f9;
            border-radius: 20px;
            padding: 20px;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        #tracingCanvas {
            display: block;
            margin: 0 auto;
            cursor: crosshair;
            touch-action: none;
            border-radius: 10px;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        button {
            background: linear-gradient(135deg, #ff6b9d, #ff8fab);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2em;
            border-radius: 25px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(255, 107, 157, 0.4);
            transition: all 0.3s ease;
            min-width: 150px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 157, 0.6);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            box-shadow: none;
        }

        .toggle-btn {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.4);
        }

        .toggle-btn:hover {
            box-shadow: 0 6px 20px rgba(78, 205, 196, 0.6);
        }

        .reset-btn {
            background: linear-gradient(135deg, #feca57, #ff9ff3);
            box-shadow: 0 4px 15px rgba(254, 202, 87, 0.4);
        }

        .reset-btn:hover {
            box-shadow: 0 6px 20px rgba(254, 202, 87, 0.6);
        }

        .success-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3em;
            color: #4ecdc4;
            font-weight: bold;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 10;
        }

        .success-message.show {
            opacity: 1;
            animation: bounce 0.6s ease;
        }

        @keyframes bounce {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
        }

        /* Star animation for success */
        .star {
            position: absolute;
            color: #ffd700;
            font-size: 2em;
            pointer-events: none;
            animation: sparkle 1s ease-out forwards;
        }

        @keyframes sparkle {
            0% {
                opacity: 1;
                transform: scale(0) rotate(0deg);
            }
            100% {
                opacity: 0;
                transform: scale(1.5) rotate(360deg);
            }
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 2em;
            }
            
            #tracingCanvas {
                width: 100%;
                height: auto;
            }
            
            button {
                padding: 12px 20px;
                font-size: 1em;
                min-width: 120px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŒŸ Letter Tracing Game ðŸŒŸ</h1>
        
        <div class="progress-container">
            <div class="progress-bar" id="progressBar">
                Letter <span id="currentLetter">A</span> of 26
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="tracingCanvas" width="400" height="400"></canvas>
            <div class="success-message" id="successMessage">âœ¨ Great Job! âœ¨</div>
        </div>

        <div class="controls">
            <button class="toggle-btn" id="caseToggle">Uppercase</button>
            <button class="reset-btn" id="resetBtn">Reset</button>
            <button id="nextBtn">Next Letter â†’</button>
        </div>
    </div>

    <script>
        // Game state
        const canvas = document.getElementById('tracingCanvas');
        const ctx = canvas.getContext('2d');
        const progressBar = document.getElementById('progressBar');
        const currentLetterSpan = document.getElementById('currentLetter');
        const successMessage = document.getElementById('successMessage');
        const caseToggle = document.getElementById('caseToggle');
        const resetBtn = document.getElementById('resetBtn');
        const nextBtn = document.getElementById('nextBtn');

        let currentLetterIndex = 0;
        let isUppercase = true;
        let isDrawing = false;
        let tracedPath = [];
        let letterPath = [];
        let isComplete = false;
        let canvasSize = 400;

        // Adjust canvas size for mobile
        function resizeCanvas() {
            const container = canvas.parentElement;
            const maxWidth = Math.min(400, container.clientWidth - 40);
            canvasSize = maxWidth;
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            drawLetter();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Letters array
        const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

        // Initialize game
        function init() {
            nextBtn.disabled = true; // Start with next button disabled
            drawLetter();
            updateProgress();
        }

        // Draw the letter as a dotted outline
        function drawLetter() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const letter = isUppercase 
                ? letters[currentLetterIndex] 
                : letters[currentLetterIndex].toLowerCase();
            
            // Set up text style
            ctx.font = `bold ${canvasSize * 0.6}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            ctx.save();
            
            // Create letter on temporary canvas to extract outline
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.font = `bold ${canvasSize * 0.6}px Arial`;
            tempCtx.textAlign = 'center';
            tempCtx.textBaseline = 'middle';
            tempCtx.fillStyle = 'black';
            tempCtx.fillText(letter, canvas.width / 2, canvas.height / 2);
            
            // Get image data to find edge pixels
            const imageData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Draw dots along the letter outline
            ctx.fillStyle = '#ff6b9d';
            const dotRadius = Math.max(5, canvasSize * 0.02);
            const dotSpacing = Math.max(10, canvasSize * 0.025);
            const edgePoints = [];
            
            // Find edge pixels more efficiently by sampling
            // Sample every 2-3 pixels for better performance
            const sampleRate = 2;
            for (let y = 0; y < canvas.height; y += sampleRate) {
                for (let x = 0; x < canvas.width; x += sampleRate) {
                    const index = (y * canvas.width + x) * 4;
                    const alpha = data[index + 3];
                    
                    if (alpha > 128) { // Part of the letter
                        // Check if it's an edge (has at least one transparent neighbor)
                        let isEdge = false;
                        // Check immediate neighbors only for speed
                        const neighbors = [
                            [-1, -1], [0, -1], [1, -1],
                            [-1, 0],           [1, 0],
                            [-1, 1],  [0, 1],  [1, 1]
                        ];
                        
                        for (const [dx, dy] of neighbors) {
                            const nx = x + dx;
                            const ny = y + dy;
                            if (nx >= 0 && nx < canvas.width && ny >= 0 && ny < canvas.height) {
                                const nIndex = (ny * canvas.width + nx) * 4;
                                if (data[nIndex + 3] < 128) {
                                    isEdge = true;
                                    break;
                                }
                            } else {
                                isEdge = true; // Edge of canvas
                                break;
                            }
                        }
                        
                        if (isEdge) {
                            edgePoints.push({x, y});
                        }
                    }
                }
            }
            
            // Draw dots at edge points with proper spacing
            // Sort points to draw in order (rough approximation)
            edgePoints.sort((a, b) => {
                // Sort by y first, then x
                if (Math.abs(a.y - b.y) > 5) return a.y - b.y;
                return a.x - b.x;
            });
            
            let lastDotX = -dotSpacing * 2;
            let lastDotY = -dotSpacing * 2;
            
            for (const point of edgePoints) {
                const dist = Math.sqrt(
                    Math.pow(point.x - lastDotX, 2) + 
                    Math.pow(point.y - lastDotY, 2)
                );
                
                if (dist >= dotSpacing) {
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, dotRadius, 0, Math.PI * 2);
                    ctx.fill();
                    lastDotX = point.x;
                    lastDotY = point.y;
                }
            }
            
            // Store letter path for collision detection
            storeLetterPath(letter);
            
            // Draw user's traced path
            if (tracedPath.length > 0) {
                // Check if last point is on letter to give visual feedback
                const lastPoint = tracedPath[tracedPath.length - 1];
                const isOnLetter = isPointOnLetter(lastPoint.x, lastPoint.y);
                
                // Use brighter color when tracing correctly
                ctx.strokeStyle = isOnLetter ? '#2ecc71' : '#4ecdc4';
                ctx.lineWidth = canvasSize * 0.06;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                ctx.beginPath();
                ctx.moveTo(tracedPath[0].x, tracedPath[0].y);
                for (let i = 1; i < tracedPath.length; i++) {
                    ctx.lineTo(tracedPath[i].x, tracedPath[i].y);
                }
                ctx.stroke();
            }
            
            ctx.restore();
        }

        // Store letter path for collision detection
        function storeLetterPath(letter) {
            // Create a temporary canvas to get the letter's pixel data
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCtx.font = `bold ${canvasSize * 0.6}px Arial`;
            tempCtx.textAlign = 'center';
            tempCtx.textBaseline = 'middle';
            tempCtx.fillStyle = 'black';
            tempCtx.fillText(letter, canvas.width / 2, canvas.height / 2);
            
            letterPath = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
        }

        // Check if point is on the letter
        function isPointOnLetter(x, y) {
            if (!letterPath) return false;
            
            const pixelX = Math.floor(x);
            const pixelY = Math.floor(y);
            
            if (pixelX < 0 || pixelX >= canvas.width || pixelY < 0 || pixelY >= canvas.height) {
                return false;
            }
            
            const index = (pixelY * canvas.width + pixelX) * 4;
            const alpha = letterPath.data[index + 3];
            
            return alpha > 128; // Threshold for detecting the letter
        }

        // Get mouse/touch position relative to canvas
        function getEventPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            if (e.touches) {
                return {
                    x: (e.touches[0].clientX - rect.left) * scaleX,
                    y: (e.touches[0].clientY - rect.top) * scaleY
                };
            } else {
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            }
        }

        // Start drawing
        function startDrawing(e) {
            e.preventDefault();
            if (isComplete) return;
            
            isDrawing = true;
            const pos = getEventPos(e);
            tracedPath = [pos];
            drawLetter();
        }

        // Continue drawing
        function continueDrawing(e) {
            e.preventDefault();
            if (!isDrawing || isComplete) return;
            
            const pos = getEventPos(e);
            tracedPath.push(pos);
            
            // Check if we're tracing over the letter
            if (isPointOnLetter(pos.x, pos.y)) {
                checkCompletion();
            }
            
            drawLetter();
        }

        // Stop drawing
        function stopDrawing(e) {
            e.preventDefault();
            if (!isDrawing) return;
            
            isDrawing = false;
            checkCompletion();
        }

        // Check if tracing is complete
        function checkCompletion() {
            if (isComplete || tracedPath.length < 10) return;
            
            // Count how many points are on the letter
            let pointsOnLetter = 0;
            const sampleSize = Math.min(50, tracedPath.length);
            const step = Math.max(1, Math.floor(tracedPath.length / sampleSize));
            
            for (let i = 0; i < tracedPath.length; i += step) {
                if (isPointOnLetter(tracedPath[i].x, tracedPath[i].y)) {
                    pointsOnLetter++;
                }
            }
            
            // If at least 20% of sampled points are on the letter, consider it complete
            // This is lenient to accommodate kids' imperfect tracing
            const coverage = pointsOnLetter / sampleSize;
            if (coverage >= 0.2) {
                completeTracing();
            }
        }

        // Complete tracing with animation
        function completeTracing() {
            isComplete = true;
            successMessage.classList.add('show');
            
            // Create sparkle stars
            createSparkles();
            
            // Hide success message after animation
            setTimeout(() => {
                successMessage.classList.remove('show');
            }, 2000);
            
            // Enable next button
            nextBtn.disabled = false;
        }

        // Create sparkle animation
        function createSparkles() {
            const container = canvas.parentElement;
            const numStars = 15;
            
            for (let i = 0; i < numStars; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.textContent = 'â­';
                
                const angle = (Math.PI * 2 * i) / numStars;
                const radius = canvasSize * 0.4;
                const x = canvas.width / 2 + Math.cos(angle) * radius;
                const y = canvas.height / 2 + Math.sin(angle) * radius;
                
                star.style.left = (x / canvas.width * 100) + '%';
                star.style.top = (y / canvas.height * 100) + '%';
                
                container.appendChild(star);
                
                setTimeout(() => {
                    star.remove();
                }, 1000);
            }
        }

        // Update progress bar
        function updateProgress() {
            const progress = ((currentLetterIndex + 1) / 26) * 100;
            progressBar.style.width = progress + '%';
            currentLetterSpan.textContent = letters[currentLetterIndex];
        }

        // Reset current letter
        function resetLetter() {
            tracedPath = [];
            isComplete = false;
            isDrawing = false;
            nextBtn.disabled = true;
            successMessage.classList.remove('show');
            drawLetter();
        }

        // Move to next letter
        function nextLetter() {
            if (currentLetterIndex < 25) {
                currentLetterIndex++;
            } else {
                // Completed all letters - restart
                currentLetterIndex = 0;
            }
            resetLetter();
            updateProgress();
        }

        // Toggle uppercase/lowercase
        function toggleCase() {
            isUppercase = !isUppercase;
            caseToggle.textContent = isUppercase ? 'Uppercase' : 'Lowercase';
            resetLetter();
        }

        // Event listeners
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', continueDrawing);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseleave', stopDrawing);

        canvas.addEventListener('touchstart', startDrawing, { passive: false });
        canvas.addEventListener('touchmove', continueDrawing, { passive: false });
        canvas.addEventListener('touchend', stopDrawing, { passive: false });
        canvas.addEventListener('touchcancel', stopDrawing, { passive: false });

        resetBtn.addEventListener('click', resetLetter);
        nextBtn.addEventListener('click', nextLetter);
        caseToggle.addEventListener('click', toggleCase);

        // Initialize the game
        init();
    </script>
</body>
</html>
